#!/bin/sh

map=(107 108 109 110 112 113 114 115 116 204 205 211 302 303 306 401 407 408 409 410 412 413 414 415 416 507 508 509 510 512 513 514 515 516)
eMAP=(0000 1000 0100 0010 0001 1100 1010 1001 0101 0110 0011 0111 1011 1101 1110 1111) 
iMAP=("1" "cdim" "rdim" "(2*r+1)*(2*r+1)" "5")
R=(0 0 0 3 1)
WG=16
host='main.cpp'
hostT='./template/main.cpp'
kernel='kernels.cl'
kernelT='./template/kernels3.cl'
report='lmReport.txt'
# ------------------------------------------------------------------
# 			start execution 
# ------------------------------------------------------------------
echo -en "   \tv1\tv2\tv3\tv4\n" >> ${report}

for index in {15..24..1}; do # for each map

	mp=${map[$index]}
	echo "map: ${mp}"
	echo -en "${mp}\t" >> ${report}
	if [ ! -d ${mp} ]; then
		mkdir ./${mp}	
	fi	
	# calculate the maximum number of data structures (let us assume 4 for now)
	N=4
	for (( n=1; n<${N}+1; n++ ))
		do
		dirName=./${mp}/v${n}
		if [ ! -d ${dirName} ]; then	# check dir exist
			mkdir ${dirName}	
		fi		
		# generate host (main)		
		# ---------------------------------------------------
			# get the four bits of a eMAP
			idx=${mp:1:2}
			if [ ${idx:0:1} -eq '0' ]; then
				idx="${idx:1:1}"
			fi
			bits=${eMAP[${idx}-1]}

			# @argOMP
			argOMP=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    argOMP="${argOMP} const float * in${nn},"
			  done
			argOMP="${argOMP%?}"
			if [ -f ${dirName}/${host} ]; then	# check file exist
				rm ${dirName}/${host}
			fi
			cat ${hostT} | sed "s/@argOMP/${argOMP}/g" > ${dirName}/${host}
	
			# @argOCL
			argOCL=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    argOCL="${argOCL} cl_mem dIn${nn},"
			  done
			argOCL="${argOCL%?}"
			cat ${dirName}/${host} | sed "s/@argOCL/${argOCL}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @hIn
			hIn="float "
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    hIn="${hIn} *hIn${nn},"
			  done
			hIn="${hIn%?}"
			cat ${dirName}/${host} | sed "s/@hIn/${hIn}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @dIn
			dIn="cl_mem "
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    dIn="${dIn} dIn${nn},"
			  done
			dIn="${dIn%?}"
			cat ${dirName}/${host} | sed "s/@dIn/${dIn}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			# @cdimIn
			idxW="" # x coordinate
			case "${bits:0:2}" in
				"00")  
				    idxW="0"
				    ;;
				"10") 
				    idxW="cdim"
				    ;;
				"01") 
				    idxW="cdim"
				    ;;
				"11") 
				    idxW="2*cdim"
				    ;;
				*)
				    idxW=""
				    ;;
			esac
			cdimIn="int cdimIn=${idxW};"
			cat ${dirName}/${host} | sed "s/@cdimIn/${cdimIn}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			# @rdimIn
			rdimIn="int rdimIn=rdim;"			
			#idxH="(${bits:2:1}*cdim)+(${bits:3:1}*rdim)"
			#rdimIn="${rdimIn} ${idxH};"
			cat ${dirName}/${host} | sed "s/@rdimIn/${rdimIn}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @elems
			elems=1+${iMAP[${mp:0:1}-1]}*${nn}
			cat ${dirName}/${host} | sed "s/@elems/${elems}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @hInAlc
			hAlc=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    hAlc="${hAlc}hIn${nn} = (float *)malloc(cdimIn * rdimIn * sizeof(float));\n\t"
			  done
			#dIn="${dIn%?}"
			cat ${dirName}/${host} | sed "s/@hAlc/${hAlc}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @hFill
			hFill=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    hFill="${hFill}fill<float>(hIn${nn}, cdimIn * rdimIn, 5);\n\t"
			  done

			cat ${dirName}/${host} | sed "s/@hFill/${hFill}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @dAlc
			dAlc=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    dAlc="${dAlc}dIn${nn} = _clMalloc(cdimIn * rdimIn * sizeof(float));\n\t"
			  done

			cat ${dirName}/${host} | sed "s/@dAlc/${dAlc}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @h2dTrans
			h2dTrans=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    h2dTrans="${h2dTrans}_clMemcpyH2D(dIn${nn}, hIn${nn}, cdimIn * rdimIn * sizeof(float));\n\t"
			  done

			cat ${dirName}/${host} | sed "s/@h2dTrans/${h2dTrans}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @oclArgs
			oclArgs=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    oclArgs="${oclArgs}dIn${nn}, "
			  done
			oclArgs="${oclArgs%?}"
			oclArgs="${oclArgs%?}"
			cat ${dirName}/${host} | sed "s/@oclArgs/${oclArgs}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @ompArgs
			ompArgs=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    ompArgs="${ompArgs}hIn${nn}, "
			  done
			ompArgs="${ompArgs%?}"
			ompArgs="${ompArgs%?}"
			cat ${dirName}/${host} | sed "s/@ompArgs/${ompArgs}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @clFree
			clFree=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    clFree="${clFree}_clFree(dIn${nn});\n\t"
			  done
			clFree="${clFree%?}"
			clFree="${clFree%?}"
			cat ${dirName}/${host} | sed "s/@clFree/${clFree}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @hFree
			hFree=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    hFree="${hFree}if(hIn${nn}!=NULL) free(hIn${nn});\n\t"
			  done
			hFree="${hFree%?}"
			hFree="${hFree%?}"
			cat ${dirName}/${host} | sed "s/@hFree/${hFree}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @xIn
			# TODO (with kernel file)
			xIn=""
			idxW="" # x coodinate
			case "${bits:0:2}" in
				"00")  
				    idxW="0"
				    ;;
				"10") 
				    idxW="c"
				    ;;
				"01") 
				    idxW="r"
				    ;;
				"11") 
				    idxW="r+c"
				    ;;
				*)
				    idxW=""
				    ;;
			esac

			idxH="" # y coordinate
			case "${bits:2:2}" in
				"00")  
				    idxH="0"
				    ;;
				"10") 
				    idxH="c"
				    ;;
				"01") 
				    idxH="r"
				    ;;
				"11") 
				    idxH="r+c"
				    ;;
				*)
				    idxH=""
				    ;;
			esac

			xIn="(${idxW})"
			cat ${dirName}/${host} | sed "s/@xIn/${xIn}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

			# @inData: in1[xIn] + in2[xIn]
			inData="for(int rr=0; rr<rdim; rr++)\n\t\t\t{\n\t\t\t\tval+="
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    inData="${inData}in${nn}[rr*cdimIn+xIn]+"
			  done
			inData="${inData%?};\n\t\t\t}"
			cat ${dirName}/${host} | sed "s/@inData/${inData}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}
			
			# @clSetArgs
			clSetArgs=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    clSetArgs="${clSetArgs}_clSetArgs(kernel_id, arg_idx++, dIn${nn});\n\t"
			  done
			clSetArgs="${clSetArgs%?}"
			clSetArgs="${clSetArgs%?}"
			cat ${dirName}/${host} | sed "s/@clSetArgs/${clSetArgs}/g" > ./tmp
			cat ./tmp > ${dirName}/${host}

		# generate kernel (kernels.cl)
		# ---------------------------------------------------
			# @radius
			radius=${R[${mp:0:1}-1]}
			rad=${R[${mp:0:1}-1]}
			radius="#define R ${radius}"
			cat ${kernelT} | sed "s/@radius/${radius}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

			# @WD
			WD=""
			wd=""
			idx=${mp:1:2}
			if [ ${idx:0:1} -eq '0' ]; then
				idx="${idx:1:1}"
			fi
			bits=${eMAP[${idx}-1]}	# xxxx
			bits=${bits:0:2}	# the first two bits
			if [ $bits -eq '11' ]; then # 11
				WD="WG*2"
				wd="${WG}*2"
			else
				WD="WG"
				wd="${WG}"
			fi
			WD="#define WD (${WD}+2*R)"
			wd="(${wd}+2*${rad})"
			cat ${dirName}/${kernel} | sed "s/@WD/${WD}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

			# @HT
			HT=""
			ht=""
			bits=${eMAP[${idx}-1]}	# xxxx
			bits=${bits:2:2}	# the first two bits
			if [ $bits -eq '11' ]; then # 11
				HT="WG*2"
				ht="${WG}*2"
			else
				HT="WG"
				ht="${WG}"
			fi
			HT="#define HT (${HT}+2*R)"
			ht="(${ht}+2*${rad})"			
			cat ${dirName}/${kernel} | sed "s/@HT/${HT}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

			# write code generation report
			echo -en "$((4*${wd}*${ht}*${n}/1024))\t" >> ${report}

			# @inArgs
			inArgs=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    inArgs="${inArgs}const __global float *in${nn}, "
			  done
			inArgs="${inArgs%?}"
			inArgs="${inArgs%?}"
			cat ${dirName}/${kernel} | sed "s/@inArgs/${inArgs}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}
		
			# @lmAlc
			lmAlc=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    lmAlc="${lmAlc}__local float LM${nn}[WD*HT];\n\t"
			  done
			lmAlc="${lmAlc%?}"
			lmAlc="${lmAlc%?}"
			cat ${dirName}/${kernel} | sed "s/@lmAlc/${lmAlc}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

			# @varDec
			varDec=""
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    varDec="${varDec}float retVal${nn} = 0.0f;\n\t"
			  done
			varDec="${varDec%?}"
			varDec="${varDec%?}"
			cat ${dirName}/${kernel} | sed "s/@varDec/${varDec}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

			# @lmLoad (use different loading strategies for different eMAPs)
			lmLoad=""
			bits=${eMAP[${idx}-1]}	# 
			case "${bits:0:4}" in
				"${eMAP[0]}") 	# eMAP-01
					;;	
				"${eMAP[1]}")	# eMAP-02
					lmLoad="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = (wgx*WD+tlx)+(rr+tly)*cdimIn;\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    lmLoad="${lmLoad}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					lmLoad="${lmLoad%?}"
					lmLoad="if(1==1){\n\t${lmLoad}}"
					;;
				"${eMAP[2]}")	# eMAP-03
					lmLoad="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = (wgy*WD+tlx)+(rr+tly)*cdimIn;\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    lmLoad="${lmLoad}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					lmLoad="${lmLoad%?}"
					lmLoad="if(1==1){\n\t${lmLoad}}"
					;;
				"${eMAP[3]}")	# eMAP-04
					lmLoad="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = (wgx*WD+tly)*cdimIn+(cc+tlx);\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    lmLoad="${lmLoad}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					lmLoad="${lmLoad%?}"
					lmLoad="if(1==1){\n\t${lmLoad}}"
					;;
				"${eMAP[4]}")	# eMAP-05
					lmLoad="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = (wgy*WD+tly)*cdimIn+(cc+tlx);\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    lmLoad="${lmLoad}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					lmLoad="${lmLoad%?}"
					lmLoad="if(1==1){\n\t${lmLoad}}"
					;;
				"${eMAP[5]}")	# eMAP-06
					loadLeft="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = (rr+tly)*cdimIn+(wgx+wgy)*HT+tlx;\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    loadLeft="${loadLeft}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					#loadTop="${loadTop%?}"

					loadRight="dl = (tly) * WD + (tlx+HT);\n\t\t\tdg = (rr+tly)*cdimIn+(wgx+wgy)*HT+HT+tlx;\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    loadRight="${loadRight}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					loadRight="${loadRight%?}"
					lmLoad="if(1==1){\n\t${loadLeft}${loadRight}}"
					;;
				"${eMAP[6]}")	# eMAP-07 (threads, local data, global data)
					;;
				"${eMAP[7]}")	#eMAP-08
					;;
				"${eMAP[8]}")	#eMAP-09
					;;
				"${eMAP[9]}")	#eMAP-10
					;;
				"${eMAP[10]}")	#eMAP-11
					loadTop="\t\tint dl = (tly) * WD + (tlx);\n\t\t\tint dg = ((wgx+wgy)*WD+tly)*cdimIn+(tlx+cc);\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    loadTop="${loadTop}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					#loadTop="${loadTop%?}"

					loadBot="dl = (tly+WD) * WD + (tlx);\n\t\t\tdg = ((wgx+wgy)*WD+tly+WD)*cdimIn+(tlx+cc);\n\t\t\t"
					for (( nn=0; nn<${n}; nn++ ))
					  do
					    loadBot="${loadBot}LM${nn}[dl] = in${nn}[dg];\n\t\t\t"
					  done
					loadBot="${loadBot%?}"
					lmLoad="if(1==1){\n\t${loadTop}${loadBot}}"
					;;
				"${eMAP[11]}")	#eMAP-12 (2 parts) HT=2*WD
					;;
				"${eMAP[12]}")	#eMAP-13
					;;
				"${eMAP[13]}")	#eMAP-14
					;;
				"${eMAP[14]}")	#eMAP-15
					;;
				"${eMAP[15]}")	#eMAP-16
					;;

				*)
					;;
			esac

			cat ${dirName}/${kernel} | sed "s/@lmLoad/${lmLoad}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}
			
			# @lmUse
			lmUse=""
			bits=${eMAP[${idx}-1]}	# xxxx
			idxW=""
			case "${bits:0:2}" in
				"00")  
				    idxW="0"
				    ;;
				"10") 
				    idxW="tlx"
				    ;;
				"01") 
				    idxW="tly"
				    ;;
				"11") 
				    idxW="tly+tlx"
				    ;;
				*)
				    idxW=""
				    ;;
			esac

			idxH=""
			case "${bits:2:2}" in
				"00")  
				    idxH="0"
				    ;;
				"10") 
				    idxH="tlx"
				    ;;
				"01") 
				    idxH="tly"
				    ;;
				"11") 
				    idxH="tly+tlx"
				    ;;
				*)
				    idxH=""
				    ;;
			esac
			lmUse="int useIdx=(${idxW});"
			lmUse="${lmUse}\n\t\tfor(ll=0; ll<HT; ll++)\n\t\t{"
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    lmUse="${lmUse}\n\t\t\tretVal${nn} += LM${nn}[useIdx+ll*WD];"
			  done
			lmUse="${lmUse}\n\t\t}"
			#lmUse="${lmUse%?}"
			cat ${dirName}/${kernel} | sed "s/@lmUse/${lmUse}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}
			
			# @lmOut
			lmOut=""			
			for (( nn=0; nn<${n}; nn++ ))
			  do
			    lmOut="${lmOut}retVal${nn}+"
			  done
			lmOut="${lmOut%?}"
			cat ${dirName}/${kernel} | sed "s/@lmOut/${lmOut}/g" > ./tmp
			cat ./tmp > ${dirName}/${kernel}

		# generate config
		# ---------------------------------------------------
		
		# copy makefile, runfile, helperfile, macro.h, config, 
		# ---------------------------------------------------
		cp ./template/Makefile ./${dirName}/
		cp ./template/macro.h ./${dirName}/
		cp ./template/kernel.config ./${dirName}/
		cp ./template/run ./${dirName}/
		cp ./template/CLHelper.h ./${dirName}/
		cp ./template/util.h ./${dirName}/

		done
	echo -en "\n" >> ${report}
done	# end for each map

# ------------------------------------------------------------------
# 			end execution 
# ------------------------------------------------------------------


